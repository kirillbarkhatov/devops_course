Требования к оформлению домашнего задания.

На https://github.com создать репозиторий, в котором каждая "лекция" - отдельная директория.

Каждое задание требуется отразить текстом.
Если вывод текста невозможен, то прикрепить скриншот с пояснением.

Вопросы:



Написать скрипт, который будет спрашивать имя пользователя и на основе ввода показывать нужную строчку из /etc/passwd.
Так же скрипт выводит построчно:
- шелл пользователя
- домашнюю директорию пользователя
- список групп, в которых он состоит
После этого скрипт должен спросить, что следует поменять – uid, домашнюю директорию или группу
Если uid, то сначала проверить, доступен ли такой uid, если нет – то один раз предложить ввести заново.
Если домашнюю директорию, то спросить, на какую директорию следует сменить, а также следует ли перемещать домашнюю директорию.
Если группу – то следует спросить, меняем ли мы основную группу или дополнительную.
После чего следует вывести на экран итоговую команду.



Написать скрипт, который будет спрашивать название и создавать файл, затем спрашивать права для этого файла и задавать их.



Написать скрипт, который должен принять на вход путь до блочного устройства, проверить примонтировано оно или нет.
Если примонтировано - завершиться с exitCode 90
Если не примонтировано, то при помощи программы mktemp создать директорию, примонтировать в неё



Создайте файл со списком пользователей. С помощью for выведите на экран содержимое файла с нумерацией строк



При помощи HEREDOC "сгенерировать" баш-скрипт, который на вход принимает три аргумента:
- вывод usage ( как пользоваться скриптом )
- количество генерируемых файлов
- маску имени генерируемых файлов
и реализует такую штуку:
Проверяет существование файла с именем скрипта и расширением lock
если файл существует, вывести содержимое файла и завершить работу с кодом 64
если файла не существует, то записать в него pid скрипта
Перейти в домашнюю директорию пользователя root
Создать именованный пайп
Создать файлы различного размера ( от 10 КБ до 800 КБ ) по маске имени, количество взять из аргумента "количество генерируемых файлов"
Перейти в директорию /tmp
Заархивировать созданные файлы при помощи созданного именованного пайпа
Вывести список файлов ( без директорий ) одновременно и на экран, и в файл
Вывести на экран время всей работы скрипта в формате unixtime



Написать скрипт, который проверяет размер примонтированных разделов дисков
Аргументы скрипта:
- вывод помощи
- процент свободного пространства
Если свободного места осталось менее процента из аргумента, отправить сообщение в телеграм
1. Поместить вызов скрипта каждые 8 минут в крон
2. * поместить задание в крон не используя утилиту crontab с параметром -e
3. **Заменить вызов cron на systemd-timers



Написать скрипт, который принимает на вход в виде аргумента IP-адрес
Скрипт должен проверить доступность адреса посредством ping три раза и записать в лог один раз за все три проверки:
- доступность хоста
- трассировку до хоста
- с какого роутера получен маршрут



Собрать nginx из исходников с модулем https://github.com/ritchie-wang/nginx-upstream-dynamic-servers
Убедиться в доступности nginx (страничку отдает или нет)
Положить nginx в созданный namespace ядра
Убедиться в доступности nginx (страничку отдает или нет)
Написать конфигурацию reverse-proxy для сайта https://mokm51.ru/



Написать скрипт, который принимает на вход два аргумента: <path> <time>
Скрипт должен вывести список файлов из <path> старше <time>
 может быть задан в любом формате, который понимает утилита date



Напишите скрипт, который использует один текстовый файл как источник данных
Файл имеет формат:
userName creationDate deletionDate homeDir
userName записывается в виде одного слова
creationDate записывается в формате unix timestamp
deletionDate записывается в формате unix timestamp, если пользователь не удалён, то используется символ тире
homeDir - путь к домашней директории пользователя
Напишите функции просмотра информации о пользователе(1), создания пользователя(2), удаления пользователя (3). Используйте case для аргументов скрипта:
Аргументы скрипта:
- s имяПользователя
- c имяПользователя
- d имяПользователя
- h путьКДомашнейДиректории
- a
s - выводит информацию о пользователе
c - добавляет пользователя с указанной в аргументе h домашней директории в файл и текущей датой
d - изменяет deletionDate с тире на текущую дату
a - выводит список всех пользователей в формате
Номер строки: имяПользователя датаСоздания датаУдаления путьКДомашнейДиректории



Написать скрипт, на вход которого подается либо PID, либо имя программы.
Скрипт постоянно проверяет что программа находится в памяти
Каждая проверка записывается в лог в формате:
день-месяц-год час-минута-секунда mySvcChecker: service <имя_сервиса> [isUP|isDown]
[isUP|isDown] - состояние сервиса



На вход скрипта подаются два аргумента
Первый аргумент - входной файл, второй - выходной файл
Если оба файла существуют, то скрипт завершает работу
Если входной файл не существует, то скрипт завершает работу
Скрипт должен вывести в выходной файл содержимое входного файла так, что бы каждая четная строка входного файла поменялась местами с предыдущей нечётной
пример входного файла:
1
2
3
4
5
6
7
8
пример выходного файла:
2
1
4
3
6
5
8
7
Порядок не важен - с начала файла или с конца, главное что бы строки поменялись местами.



При помощи утилиты nc отправить-принять с одного на другой сервер любое сообщение по TCP и по UDP
При помощи tcpdump посмотреть как устанавливается подключение, сообщение пересылается
Поменять mac-address, параллельно посмотреть tcpdump-ом что происходит



Переводим SELinux в Permissive режим
Пишем скрипт, который слушает 60 порт tcp ( неважно чем - хоть nc )
При подключении клиента к 60 порту ( telnet / nc ), скрипт выдает приветствие.
Если скрипт на 60 порту получил сообщение от клиента:
getDate
, то должен выдать текущую дату в формате ГОД-МЕСЯЦ-ДЕНЬ ЧАС-МИНУТА-СЕКУНДА
getEpoch
, то должен выдать время в unixtime
getInetStats
, то отдаем статистику всех сетевых карт
getInetStats <имяКарты>
, то отдаем статистику указанной сетевой карты
bye
, то завершить сессию
В ходе работы должен вестись лог в формате:
ГОД-МЕСЯЦ-ДЕНЬ ЧАС-МИНУТА-СЕКУНДА ПИД локальныйИП удаленныйИП командаОтКлиента результатВыполнения



Берём ранее сконфигурированный nginx
Включаем SELinux в режим Enforcing
Создаем директорию
/pubHtml
В конфиге web-сервера сменить root-директорию с дефолтной на /pubHtml
Кладём любой файл в /pubHtml
В качестве примера можно использовать файл index.html с содержимым
<html><body><h2>test file
При помощи утилит audit2allow и setroubleshoot разрешаем работу httpd-демона с /pubHtml
При обращении к виртуальной машине по IP-адресу на 80/tcp-порт получаем свой файл из директории /pubHtml от web-сервера
Добавляем в конфигурацию веб-сервера порт 4589
При обращении к виртуальной машине по IP-адресу на 4589/tcp-порт получаем свой файл из директории /pubHtml от web-сервера
Разрешаем работу скрипта при помощи утилит audit2allow и setroubleshoot



firewalld
Нарисовать правило сервиса с указанным портом (см. ниже) для публичной зоны в виде файла, который необходимо положить в то место, из которого firewalld читает правила.
На машине 1 запустить nc на любом порту в режиме прослушивания. На этой машине должно быть правило из пункта выше
На машине 2 запустить nc с подключением к машине 1
Изменить правило сервиса так, что бы подключение с машины 2 к машине 1 отбрасывалось
iptables
Написать правила для доступа к порту 22/tcp только для выделенного списка адресов, всем остальным адресам доступ запрещен
